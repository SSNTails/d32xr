#target ram
#code SRAM, $0000

; VGM player Z80 driver
; Joe Fenton (C)2023

; 32X Technical Notes
; 15. Z80 writes to $840000-$9FFFFF and $A15100-$A153FF will lock
;     the 68000. Writes to MD work RAM and PSG are allowed.
; 22. The Z80 bank shift register must not be set to $000000-
;     $3FFFFF or $840000-$9FFFFF. The 68000 may get inconsistent
;     data, and the 32X registers may become corrupted.


ACCURATE    EQU 1       ; set to 0 for 1.25, 1 for 1.1953125

LOCAL_MEM   EQU $0040   ; player variable base address
FM_IDX      EQU $00     ; music track index
FM_CSM      EQU $01     ; music CSM mode
FM_SMPL     EQU $02     ; music delay in samples (low)
FM_SMPH     EQU $03     ; music delay in samples (high)
FM_TICL     EQU $04     ; music timer ticks (low)
FM_TICH     EQU $05     ; music timer ticks (high)
FM_TTTL     EQU $06     ; music time to tick (low)
FM_TTTH     EQU $07     ; music time to tick (high)

FM_BUFCSM   EQU $08     ; music buffers consumed
FM_BUFGEN   EQU $09     ; music buffers generated

FM_RQPND    EQU $0A     ; 68000 request pending
FM_RQARG    EQU $0B     ;   request argument (if any)

FM_START    EQU $0C     ; start offset in sram (for starting/looping vgm)

CRITICAL    EQU $0F     ; Z80 critical section flag

VGMBUF      EQU $1000   ; last 4KB of sram holds VGM data (eight banks of 512 bytes)
VGMTOP      EQU $2000   ;

YM2612      EQU $4000   ; YM2612 base address
YMPORT0     EQU $00     ; YM2612 port 0 index
YMPORT1     EQU $01     ; YM2612 port 0 data
YMPORT2     EQU $02     ; YM2612 port 1 index
YMPORT3     EQU $03     ; YM2612 port 1 data

BANKREG     EQU $6000   ; Bank register
PSGPORT     EQU $7F11   ; PSG port


; variables at the top of 68000 work ram

MD_BANK     EQU $8000   ; base address of MD space bank in Z80 map


;;;; DLG: New variables! ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
CH_PARAMS   EQU $10

FM1_POS     EQU $10
FM1_TICH    EQU $11
FM1_TICL    EQU $12
FM1_TICLL   EQU $12
FM1_TICLH   EQU $13

FM2_POS     EQU $14
FM2_TICH    EQU $15
FM2_TICL    EQU $16
FM2_TICLL   EQU $16
FM2_TICLH   EQU $17

FM3_POS     EQU $18
FM3_TICH    EQU $19
FM3_TICL    EQU $1A
FM3_TICLL   EQU $1A
FM3_TICLH   EQU $1B

FM4_POS     EQU $1C
FM4_TICH    EQU $1D
FM4_TICL    EQU $1E
FM4_TICLL   EQU $1E
FM4_TICLH   EQU $1F

FM5_POS     EQU $20
FM5_TICH    EQU $21
FM5_TICL    EQU $22
FM5_TICLL   EQU $22
FM5_TICLH   EQU $23

FM6_POS     EQU $24
FM6_TICH    EQU $25
FM6_TICL    EQU $26
FM6_TICLL   EQU $26
FM6_TICLH   EQU $27

PSG1_POS    EQU $28
PSG1_TICH   EQU $29
PSG1_TICL   EQU $2A
PSG1_TICLL  EQU $2A
PSG1_TICLH  EQU $2B

PSG2_POS    EQU $2C
PSG2_TICH   EQU $2D
PSG2_TICL   EQU $2E
PSG2_TICLL  EQU $2E
PSG2_TICLH  EQU $2F

PSG3_POS    EQU $30
PSG3_TICH   EQU $31
PSG3_TICL   EQU $32
PSG3_TICLL  EQU $32
PSG3_TICLH  EQU $33

PSG4_POS    EQU $34
PSG4_TICH   EQU $35
PSG4_TICL   EQU $36
PSG4_TICLL  EQU $36
PSG4_TICLH  EQU $37

PWM1_POS    EQU $38
PWM1_TICH   EQU $39
PWM1_TICL   EQU $3A
PWM1_TICLL  EQU $3A
PWM1_TICLH  EQU $3B

PWM2_POS    EQU $3C
PWM2_TICH   EQU $3D
PWM2_TICL   EQU $3E
PWM2_TICLL  EQU $3E
PWM2_TICLH  EQU $3F

NEXT_WAIT   EQU $FFE8

CUR_CH      EQU $FFEC
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


REQ_ATTR    EQU $FFEE
REQ_ACT     EQU $FFEF   ; request action by 68000

STRM_KON    EQU $FFF0
STRM_ID     EQU $FFF1
STRM_CHIP   EQU $FFF2
STRM_LMODE  EQU $FFF3
STRM_SSIZE  EQU $FFF4
STRM_SBASE  EQU $FFF5
STRM_FREQH  EQU $FFF6
STRM_FREQL  EQU $FFF7
STRM_OFFHH  EQU $FFF8
STRM_OFFHL  EQU $FFF9
STRM_OFFLH  EQU $FFFA
STRM_OFFLL  EQU $FFFB
STRM_LENHH  EQU $FFFC
STRM_LENHL  EQU $FFFD
STRM_LENLH  EQU $FFFE
STRM_LENLL  EQU $FFFF

STRM_DRUMI  EQU $FFF9
STRM_DRUMV  EQU $FFFA
STRM_DRUMP  EQU $FFFB

; ########################### Code starts here ##############################

;   ORG $0000

; basic init code
    DI                          ; Disable ints
    LD      SP,$1000            ; Setup stack (half-way to end of sram)
    IM      1                   ; Set int mode 1
    JP      start               ; Jump to start


; ########################## Interrupt handler ##############################

;   ORG     $0058
    defs    $0058 - $

interrupt
    RETI


; ############################## Main code ##################################

;   ORG     $00A0
    defs    $00A0 - $

start
    LD      DE,$FF80            ; bank set to top 32KB of 68000 Work RAM
    CALL    set_bank

start_loop
    LD      A,(LOCAL_MEM+FM_IDX)
    OR      A
    JR      Z,start_loop        ; not playing VGM music

    LD      BC,(LOCAL_MEM+FM_START)
    LD      HL,VGMBUF
    ADD     HL,BC
    LD      DE,VGMTOP
    LD      IX,LOCAL_MEM
    LD      IY,YM2612
    LD      (IX+FM_CSM),$15
    EXX
    LD      IX,LOCAL_MEM
    LD      IY,YM2612

init_vars
    PUSH    HL
    LD      HL,CH_PARAMS
    LD      BC,0
init_vars_loop
    LD      (HL),BC
    INC     L
    INC     L
    LD      L,A
    CP      $40
    JP      NZ,init_vars_loop

    POP     HL

    LD      (CUR_CH),A

init_voices
    JP      load_voice
load_voice_return

init_timer
    LD      (IY+YMPORT0),$27
    LD      A,$10
    LD      (IY+YMPORT1),A      ; reset timer A
    LD      (IY+YMPORT0),$24
    LD      (IY+YMPORT1),A      ; set timer A msbs
    LD      (IY+YMPORT0),$25
    LD      (IY+YMPORT1),A      ; set timer A lsbs
    LD      (IY+YMPORT0),$27
    LD      A,5
    LD      (IY+YMPORT1),A      ; start timer A

next_channel
    ; READ TIMER REGISTERS
    ; STORE TIMER *SOMEWHERE*
    ; COMPARE EACH WAIT VALUE
    ; FIND THE LOWEST WAIT AND STORE IN 'NEXT_WAIT'
    ; WHENEVER 'NEXT_WAIT' IS UPDATED, UPDATE 'CUR_CH' WITH IT
    ; IF 'NEXT_WAIT' IS HIGHER THAN CURRENT TIME, LOOP UNTIL DIFFERENCE IS ZERO

    ;LD      ; DLG: Finish me!!!

play_loop_exx
    EXX
play_loop
    LD      A,(HL)              ; fetch next VGM byte
; increment vgm data ptr
    INC     L
    JP      NZ,dispatch         ; still on same page
    INC     H
    BIT     0,H
    CALL    Z,next_buffer       ; done two pages (each buffer is two pages)

dispatch
    LD      C,A

compare_type_note_off
    CP      $0                      ; if command == $0 (is it a note off command?)
    JP      Z,cmd_type_note_off

compare_type_spec
    CP      $C0                     ; if command < $C0 (is it NOT a special command?)
    JP      C,compare_type_note

jmp_spec
    JP      play_loop
    ; REMOVE JUMP ABOVE!
    LD      BC,spec_table
    PUSH    HL

    LD      H,0
    LD      L,A                     ; move command byte into HL
    ADD     HL,HL                   ; double HL
    ADD     HL,BC                   ; add spec_table offset to HL

    LD      A,(HL)                  ; retrieve first byte from spec_table
    INC     HL
    LD      H,(HL)                  ; retrieve second byte from spec_table
    LD      L,A
    JP      (HL)                    ; jump to appropriate command code

spec_table:
    .DW     cmd_wait_8bit
    .DW     cmd_wait_16bit
    .DW     0
    .DW     0
    .DW     0
    .DW     0
    .DW     0
    .DW     0
    .DW     cmd_stereo_off
    .DW     cmd_stereo_right
    .DW     cmd_stereo_left
    .DW     cmd_stereo_both
    .DW     cmd_octave_set
    .DW     cmd_voice_set
    .DW     cmd_vibrato_off
    .DW     cmd_vibrato_set

cmd_type_note_off
    LD      A,(CUR_CH)          ; stop note on current channel with all operators
    LD      B,$28               ; address: note on/off
    LD      (IY+YMPORT0),B
    LD      (IY+YMPORT1),A      ; write dd to YM2612 port 0 register aa

    JP      play_loop

compare_type_note
    CP      $40                     ; if command < $40 (is it a wait command?)
    JP      C,cmd_type_wait
    ; Continue into cmd_type_note

cmd_type_note
    ; A = command (note) values

    PUSH    HL

    ; Store the note's frequency table offset in HL.
    SUB     $29
    ADD     A,A
    LD      H,0
    LD      L,A
    LD      BC,freq_table       ; Get the note's frequency.
    ADD     HL,BC

    ; Stop any note that is currently playing on the channel.
    LD      A,(CUR_CH)          ; stop note on channel 1 with all operators
    LD      B,$28               ; address: note on/off
    LD      (IY+YMPORT0),B
    LD      (IY+YMPORT1),A      ; write dd to YM2612 port 0 register aa

    ; Fetch the frequency for the new note.
    LD      A,(HL)
    LD      B,A
    INC     HL
    LD      A,(HL)
    LD      C,A
    
    PUSH    DE

    LD      A,(CUR_CH)
    LD      D,A

    ; Store the frequency high-byte value in register 0xA4
    LD      A,$A4               ; address: channel frequency high byte
    ADD     A,D
    LD      (IY+YMPORT0),A
    LD      (IY+YMPORT1),C      ; write dd to YM2612 port 0 register aa

    ; Store the frequency low-byte value in register 0xA0
    LD      A,$A0               ; address: channel frequency low byte
    ADD     A,D
    LD      (IY+YMPORT0),A
    LD      (IY+YMPORT1),B      ; write dd to YM2612 port 0 register aa

    ; Play the new note.
    LD      B,$28               ; address: note on/off
    LD      A,$F0               ; play note on channel 1 with all operators
    ADD     A,D
    LD      (IY+YMPORT0),B
    LD      (IY+YMPORT1),A      ; write dd to YM2612 port 0 register aa

    POP     DE

    POP     HL

    JP      play_loop


freq_table
    .DW     (2048*0)+81     ; C
    .DW     (2048*0)+85     ; C#
    .DW     (2048*0)+91     ; D
    .DW     (2048*0)+96     ; D#
    .DW     (2048*0)+102     ; E
    .DW     (2048*0)+108     ; F
    .DW     (2048*0)+114     ; F#
    .DW     (2048*0)+121     ; G

    .DW     (2048*0)+128    ; G#
    .DW     (2048*0)+136    ; A
    .DW     (2048*0)+144    ; A#
    .DW     (2048*0)+152    ; B
    .DW     (2048*0)+161     ; C
    .DW     (2048*0)+171     ; C#
    .DW     (2048*0)+181     ; D
    .DW     (2048*0)+192     ; D#
    .DW     (2048*0)+203     ; E
    .DW     (2048*0)+215     ; F
    .DW     (2048*0)+228     ; F#
    .DW     (2048*0)+242     ; G

    .DW     (2048*0)+256    ; G#
    .DW     (2048*0)+271    ; A
    .DW     (2048*0)+287    ; A#
    .DW     (2048*0)+304    ; B
    .DW     (2048*0)+323     ; C
    .DW     (2048*0)+342     ; C#
    .DW     (2048*0)+362     ; D
    .DW     (2048*0)+384     ; D#
    .DW     (2048*0)+406     ; E
    .DW     (2048*0)+431     ; F
    .DW     (2048*0)+456     ; F#
    .DW     (2048*0)+483     ; G

    .DW     (2048*0)+512    ; G#
    .DW     (2048*0)+542    ; A
    .DW     (2048*0)+575    ; A#
    .DW     (2048*0)+609    ; B
    .DW     (2048*0)+645     ; C
    .DW     (2048*0)+683     ; C#
    .DW     (2048*0)+724     ; D
    .DW     (2048*0)+767     ; D#
    .DW     (2048*0)+813     ; E
    .DW     (2048*0)+861     ; F
    .DW     (2048*0)+912     ; F#
    .DW     (2048*0)+967     ; G

    .DW     (2048*0)+1024    ; G#
    .DW     (2048*0)+1085    ; A
    .DW     (2048*0)+1149    ; A#
    .DW     (2048*0)+1218    ; B
    .DW     (2048*0)+1290     ; C
    .DW     (2048*0)+1367     ; C#
    .DW     (2048*0)+1448     ; D
    .DW     (2048*0)+1534     ; D#
    .DW     (2048*0)+1625     ; E
    .DW     (2048*0)+1722     ; F
    .DW     (2048*0)+1825     ; F#
    .DW     (2048*0)+1933     ; G

    .DW     (2048*1)+1024    ; G#
    .DW     (2048*1)+1085    ; A
    .DW     (2048*1)+1149    ; A#
    .DW     (2048*1)+1218    ; B
    .DW     (2048*1)+1290     ; C
    .DW     (2048*1)+1367     ; C#
    .DW     (2048*1)+1448     ; D
    .DW     (2048*1)+1534     ; D#
    .DW     (2048*1)+1625     ; E
    .DW     (2048*1)+1722     ; F
    .DW     (2048*1)+1825     ; F#
    .DW     (2048*1)+1933     ; G

    .DW     (2048*2)+1024    ; G#
    .DW     (2048*2)+1085    ; A
    .DW     (2048*2)+1149    ; A#
    .DW     (2048*2)+1218    ; B
    .DW     (2048*2)+1290     ; C
    .DW     (2048*2)+1367     ; C#
    .DW     (2048*2)+1448     ; D
    .DW     (2048*2)+1534     ; D#
    .DW     (2048*2)+1625     ; E
    .DW     (2048*2)+1722     ; F
    .DW     (2048*2)+1825     ; F#
    .DW     (2048*2)+1933     ; G

    .DW     (2048*3)+1024    ; G#
    .DW     (2048*3)+1085    ; A
    .DW     (2048*3)+1149    ; A#
    .DW     (2048*3)+1218    ; B
    .DW     (2048*3)+1290     ; C
    .DW     (2048*3)+1367     ; C#
    .DW     (2048*3)+1448     ; D
    .DW     (2048*3)+1534     ; D#
    .DW     (2048*3)+1625     ; E
    .DW     (2048*3)+1722     ; F
    .DW     (2048*3)+1825     ; F#
    .DW     (2048*3)+1933     ; G

    .DW     (2048*4)+1024    ; G#
    .DW     (2048*4)+1085    ; A
    .DW     (2048*4)+1149    ; A#
    .DW     (2048*4)+1218    ; B
    .DW     (2048*4)+1290     ; C
    .DW     (2048*4)+1367     ; C#
    .DW     (2048*4)+1448     ; D
    .DW     (2048*4)+1534     ; D#
    .DW     (2048*4)+1625     ; E
    .DW     (2048*4)+1722     ; F
    .DW     (2048*4)+1825     ; F#
    .DW     (2048*4)+1933     ; G

    .DW     (2048*5)+1024    ; G#
    .DW     (2048*5)+1085    ; A
    .DW     (2048*5)+1149    ; A#
    .DW     (2048*5)+1218    ; B
    .DW     (2048*5)+1290     ; C
    .DW     (2048*5)+1367     ; C#
    .DW     (2048*5)+1448     ; D
    .DW     (2048*5)+1534     ; D#
    .DW     (2048*5)+1625     ; E
    .DW     (2048*5)+1722     ; F
    .DW     (2048*5)+1825     ; F#
    .DW     (2048*5)+1933     ; G

    .DW     (2048*6)+1024    ; G#
    .DW     (2048*6)+1085    ; A
    .DW     (2048*6)+1149    ; A#
    .DW     (2048*6)+1218    ; B
    .DW     (2048*6)+1290     ; C
    .DW     (2048*6)+1367     ; C#
    .DW     (2048*6)+1448     ; D
    .DW     (2048*6)+1534     ; D#
    .DW     (2048*6)+1625     ; E
    .DW     (2048*6)+1722     ; F
    .DW     (2048*6)+1825     ; F#
    .DW     (2048*6)+1933     ; G

    .DW     (2048*7)+1024    ; G#
    .DW     (2048*7)+1085    ; A
    .DW     (2048*7)+1149    ; A#
    .DW     (2048*7)+1218    ; B
    .DW     (2048*7)+1290     ; C
    .DW     (2048*7)+1367     ; C#
    .DW     (2048*7)+1448     ; D
    .DW     (2048*7)+1534     ; D#
    .DW     (2048*7)+1625     ; E
    .DW     (2048*7)+1722     ; F
    .DW     (2048*7)+1825     ; F#
    .DW     (2048*7)+1933     ; G

cmd_type_wait
    ; COMMAND: wait
    ; A = wait value

    PUSH    HL
    PUSH    IY

    LD      IY,(CUR_CH)

    LD      C,A             ; Backup the command

    LD      H,0
    LD      L,A
    LD      BC,(IY+FM1_TICL)
    ADD     HL,BC

    LD      A,B
    CP      0                           ; if MSB != 0 (time hasn't wrapped around)
    JP      NZ,cmd_type_wait_continue
    LD      A,C
    CP      L                           ; if command value <= timer LSB
    JP      C,cmd_type_wait_continue
    JP      Z,cmd_type_wait_continue

cmd_type_wait_extend_timer
    LD      A,(IY+FM1_TICH);
    INC     A
    LD      (IY+FM1_TICH),A

cmd_type_wait_continue
    LD      (IY+FM1_TICL),HL

    POP     IY
    POP     HL

    JP      next_channel


;    ;;;;;;; OLD STUFF ;;;;;;;
;    PUSH    HL
;    LD      HL,0
;    LD      BC,1024
;cmd_type_wait_loop
;    ADD     HL,BC
;    SUB     A,1
;    CP      0
;    JP      NZ,cmd_type_wait_loop
;    LD      (LOCAL_MEM+FM_SMPL),HL
;    POP     HL
;    EXX
;    JP      calc_timer


load_voice
    PUSH    HL

    LD      HL,voice_param_table

    LD      A,(CUR_CH)
    LD      C,A
    
    LD      A,$B0               ; register
    ADD     A,C
    LD      B,(HL)
    LD      (IY+YMPORT0),A
    LD      (IY+YMPORT1),B      ; write dd to YM2612 port 0 register aa
    INC     HL

    LD      A,$30               ; set initial destination register
    ADD     A,C
    LD      B,A
load_voice_byte_loop
    LD      A,(HL)              ; read voice byte
    LD      (IY+YMPORT0),B
    LD      (IY+YMPORT1),A      ; write dd to YM2612 port 0 register aa
    INC     HL
    LD      A,B
    ADD     A,$4
    LD      B,A
    CP      $90
    JP      C,load_voice_byte_loop  ; If register number < 0x90, keep looping

    POP     HL
    
    JP      load_voice_return


voice_param_table
    ; Guitar (Kid Chameleon)
    ;.DB     $38                     ; $B0 : FB/ALG
    ;.DB     $71, $72, $64, $73      ; $30 : DT/MUL
    ;.DB     $25, $19, $07, $11      ; $40 : TL
    ;.DB     $55, $5B, $1D, $1D      ; $50 : RS/AR
    ;.DB     $02, $8F, $0F, $04      ; $60 : AM/D1R
    ;.DB     $03, $00, $03, $01      ; $70 : D2R
    ;.DB     $66, $03, $13, $56      ; $80 : D1L/RR

    ; Bass (Sonic 2 (SW) - Casino Night Zone 2P)
    .DB     $08                     ; $B0 : FB/ALG
    .DB     $09, $30, $70, $00      ; $30 : DT/MUL
    .DB     $25, $13, $30, $80      ; $40 : TL
    .DB     $1F, $5F, $1F, $5F      ; $50 : RS/AR
    .DB     $12, $0A, $0E, $0A      ; $60 : AM/D1R
    .DB     $00, $04, $04, $03      ; $70 : D2R
    .DB     $2F, $2F, $2F, $2F      ; $80 : D1L/RR

    ; Lead (SOnic 2 (SW) - Casino Night Zone 2P)
    .DB     $3A                     ; $B0 : FB/ALG
    .DB     $01, $01, $07, $01      ; $30 : DT/MUL
    .DB     $17, $27, $28, $80      ; $40 : TL
    .DB     $8E, $8D, $8E, $53      ; $50 : RS/AR
    .DB     $0E, $0E, $0E, $03      ; $60 : AM/D1R
    .DB     $00, $00, $00, $00      ; $70 : D2R
    .DB     $1F, $1F, $FF, $0F      ; $80 : D1L/RR


cmd_wait_8bit
    POP     HL
cmd_wait_16bit
    POP     HL
cmd_stereo_off
    POP     HL
cmd_stereo_right
    POP     HL
cmd_stereo_left
    POP     HL
cmd_stereo_both
    POP     HL
cmd_octave_set
    POP     HL
cmd_voice_set
    POP     HL
cmd_vibrato_off
    POP     HL
cmd_vibrato_set
    POP     HL










    LD      B,A
    AND     $F0
    CP      $70
    JP      Z,wait_nn           ; wait nn+1 sample periods
    LD      A,B
    CP      $50
    JP      Z,write_psg         ; write value dd to PSG
    CP      $52
    JP      Z,write_fm0         ; write value dd to YM2612 Port 0 register aa
    CP      $53
    JP      Z,write_fm1         ; write value dd to YM2612 Port 1 register aa
    CP      $62
    JP      Z,wait_735          ; wait 735 sample periods (1/60th sec)
    CP      $61
    JP      Z,wait_nnnn         ; wait nnnn sample periods
    CP      $95
    JP      Z,strm_fast         ; stream fast start
    CP      $66
    JP      Z,end_data          ; end of sound data
; unsupported command
    JP      end_data


waiting
    LD      A,(IY+YMPORT0)
    OR      A
    JP      M,waiting           ; busy
    BIT     0,A
    JR      Z,waiting           ; timer A not overflowed
; timer A overflow
    LD      HL,(LOCAL_MEM+FM_TICL)
    LD      BC,(LOCAL_MEM+FM_TTTL)
    OR      A                   ; clear carry
    SBC     HL,BC
    LD      (LOCAL_MEM+FM_TICL),HL  ; FM_TIC = FM_TIC - FM_TTT
    JR      NZ,set_timer        ; more ticks to wait
; delay done, process commands
    XOR     A
    LD      (IX+FM_SMPL),A
    LD      (IX+FM_SMPH),A
    LD      (IX+FM_TTTL),A
    LD      (IX+FM_TTTH),A
    JP      play_loop_exx

; timer ticks ~= sample delay * 1.2
calc_timer
    LD      HL,(LOCAL_MEM+FM_SMPL)
#if ACCURATE
    LD      BC,54928            ; 65535 / 1.1953125
    OR      A                   ; clear carry
    SBC     HL,BC
    JR      NC,overflow
    ADD     HL,BC
    LD      BC,HL
    SRL     B
    RR      C
    SRL     B
    RR      C
    SRL     B
    RR      C                   ; samples/8
    PUSH    BC
    SRL     B
    RR      C                   ; samples/16
    PUSH    BC
    SRL     B
    RR      C
    SRL     B
    RR      C
    SRL     B
    RR      C                   ; samples/128
    ADD     HL,BC
    POP     BC
    ADD     HL,BC
    POP     BC
    ADD     HL,BC               ; ticks = samples * 1.1953125
    JR      set_timer
#else
    LD      BC,HL
    SRL     B
    RR      C
    SRL     B
    RR      C                   ; samples >> 2
    ADD     HL,BC               ; ticks = samples * 1.25
    JR      NC,set_timer
#endif
overflow
    LD      HL,$FFFF
set_timer
    LD      (LOCAL_MEM+FM_TICL),HL  ; save total ticks
    LD      (LOCAL_MEM+FM_TTTL),HL  ; ticks for timer A = ticks
    LD      BC,$0400                ; max ticks for timer A (1024)
    OR      A                       ; clear carry
    SBC     HL,BC
    JR      C,set_tmr               ; ticks <= max ticks for timer A
    LD      (LOCAL_MEM+FM_TTTL),BC  ; use max ticks for timer A

set_tmr
    LD      HL,$0400
    LD      BC,(LOCAL_MEM+FM_TTTL)
    OR      A                   ; clear carry
    SBC     HL,BC               ; timer A count = $0400 - ticks for timer A
    LD      A,L
    AND     $03                 ; two lsbs = ttt & 3
    LD      E,A                 ; save two lsbs
    SRL     H
    RR      L
    SRL     H
    RR      L                   ; eight msbs = ttt >> 2
    LD      D,L                 ; save eight msbs

    LD      (IY+YMPORT0),$27
    LD      A,(IX+FM_CSM)
    AND     $FE
    LD      (IY+YMPORT1),A      ; reset timer A (keep current CSM)
    LD      (IY+YMPORT0),$24
    LD      (IY+YMPORT1),D      ; set timer A msbs
    LD      (IY+YMPORT0),$25
    LD      (IY+YMPORT1),E      ; set timer A lsbs
    LD      (IY+YMPORT0),$27
    OR      $01
    LD      (IY+YMPORT1),A      ; start timer A (keep current CSM)
    JP      waiting


next_buffer
; done two pages, signal 68000 to load another buffer
    EX      AF,AF'              ; save A
wait_pend
    LD      A,(IX+FM_RQPND)
    OR      A
    JR      NZ,wait_pend        ; request still pending

    LD      A,$FF
    LD      (REQ_ACT),A         ; request action - locked
    LD      (IX+FM_RQPND),A     ; request pending

    LD      A,(IX+FM_BUFCSM)
    INC     A
    LD      (IX+FM_BUFCSM),A    ; one more consumed
    LD      (IX+FM_RQARG),A     ; request arg = # buffers consumed & 0xFF

    LD      A,$01
    LD      (REQ_ACT),A         ; request action - read buffer

buf_wait
    LD      A,(IX+FM_BUFGEN)
    CP      (IX+FM_BUFCSM)
    JR      Z,buf_wait          ; make sure we have at least one buffer ready
    EX      AF,AF'              ; restore A

    ; check buffer wrap around
    OR      A                   ; clear carry
    SBC     HL,DE
    ADD     HL,DE               ; 16-bit compare
    JR      NZ,fetch_exit       ; haven't reached end of buffer
    LD      HL,VGMBUF           ; wrap around

fetch_exit
    RET


; write value dd to PSG
write_psg
    LD      A,(HL)              ; fetch dd
; increment vgm data ptr
    INC     L
    JP      NZ,set_psg          ; still on same page
    INC     H
    BIT     0,H
    CALL    Z,next_buffer       ; done two pages (each buffer is two pages)
set_psg
    LD      (PSGPORT),A         ; write dd to PSG
    JP      play_loop

; write value dd to YM2612 Port 0 register aa
write_fm0
    LD      A,(HL)              ; fetch aa
; increment vgm data ptr
    INC     L
    JP      NZ,get_fm0_dd       ; still on same page
    INC     H
    BIT     0,H
    CALL    Z,next_buffer       ; done two pages (each buffer is two pages)
get_fm0_dd
    LD      B,(HL)              ; fetch dd
; increment vgm data ptr
    INC     L
    JP      NZ,set_fm0          ; still on same page
    INC     H
    BIT     0,H
    CALL    Z,next_buffer       ; done two pages (each buffer is two pages)
set_fm0
    CP      $27                 ; check if writing CSM
    JR      NZ,wr_fm0           ; no
    LD      A,B
    AND     $40                 ; keep CSM bit
    OR      $15
    LD      (IX+FM_CSM),A
    LD      B,A
    LD      A,$27

wr_fm0
    LD      (IY+YMPORT0),A
    LD      (IY+YMPORT1),B      ; write dd to YM2612 port 0 register aa
    JP      play_loop

; write value dd to YM2612 Port 1 register aa
write_fm1
    LD      A,(HL)              ; fetch aa
; increment vgm data ptr
    INC     L
    JP      NZ,get_fm1_dd       ; still on same page
    INC     H
    BIT     0,H
    CALL    Z,next_buffer       ; done two pages (each buffer is two pages)
get_fm1_dd
    LD      B,(HL)              ; fetch dd
; increment vgm data ptr
    INC     L
    JP      NZ,set_fm1          ; still on same page
    INC     H
    BIT     0,H
    CALL    Z,next_buffer       ; done two pages (each buffer is two pages)
set_fm1
    LD      (IY+YMPORT2),A
    LD      (IY+YMPORT3),B      ; write dd to YM2612 port 1 register aa
    JP      play_loop

; wait nnnn sample periods
wait_nnnn
    LD      C,(HL)              ; fetch nn LSB
; increment vgm data ptr
    INC     L
    JP      NZ,get_nn_msb       ; still on same page
    INC     H
    BIT     0,H
    CALL    Z,next_buffer       ; done two pages (each buffer is two pages)
get_nn_msb
    LD      B,(HL)              ; fetch nn MSB
; increment vgm data ptr
    INC     L
    JP      NZ,set_nnnn         ; still on same page
    INC     H
    BIT     0,H
    CALL    Z,next_buffer       ; done two pages (each buffer is two pages)
set_nnnn
    LD      (LOCAL_MEM+FM_SMPL),BC
    EXX
    JP      calc_timer

; wait 735 sample periods (1/60th sec)
wait_735
    LD      BC,735
    LD      (LOCAL_MEM+FM_SMPL),BC
    EXX
    JP      calc_timer

; wait 22050 sample periods (1/2 sec)
wait_test
    LD      BC,735
    LD      (LOCAL_MEM+FM_SMPL),BC
    EXX
    JP      calc_timer

; end of sound data
end_data
    LD      A,$FF
    LD      (REQ_ACT),A         ; request action - locked
    LD      (IX+FM_RQPND),A     ; request pending

    XOR     A
    LD      (IX+FM_IDX),A       ; music stopped
    LD      A,$02
    LD      (REQ_ACT),A         ; request action - music ended

end_wait
    LD      A,(IX+FM_RQPND)
    OR      A
    JR      NZ,end_wait

    LD      SP,$1000            ; reset stack (half-way to end of sram)
    LD      A,(LOCAL_MEM+FM_IDX)
    OR      A
    JP      Z,start_loop        ; not playing VGM music

    LD      BC,(LOCAL_MEM+FM_START)
    LD      HL,VGMBUF
    ADD     HL,BC
    CALL    next_buffer
    JP      play_loop           ; restart player

; wait nn+1 sample periods
wait_nn
    LD      A,B
    AND     $0F
    INC     A
    LD      C,A
    LD      B,0
    LD      (LOCAL_MEM+FM_SMPL),BC
    EXX
    JP      calc_timer


; Some notes for streams on the MD
;   There is only one YM2612, and thus only one DAC,
;   and thus only one stream. We can probably just
;   ignore it. We are also assuming an optimized VGM
;   with only one data block using stream command 93
;   to play samples.
;
;   We currently assume the length mode is 01, and
;   hence the number of samples to play at the set
;   frequency.

strm_get
    LD      A,(HL)              ; next VGM byte
; increment vgm data ptr
    INC     L
    JP      NZ,sgexit           ; still on same page
    INC     H
    BIT     0,H
    CALL    Z,next_buffer       ; done two pages (each buffer is two pages)
sgexit
    RET

; stream fast start
strm_fast
    LD      A,(IX+FM_RQPND)
    OR      A
    JR      NZ,strm_fast        ; request still pending

    CALL    strm_get            ; stream ID
    PUSH    AF
    CALL    strm_get            ; block ID low
    PUSH    AF
    CALL    strm_get            ; block ID high
    PUSH    AF
    CALL    strm_get            ; flags (0x01 == loop, 0x10 == reverse)
    PUSH    AF

    LD      A,$FF
    LD      (REQ_ACT),A         ; request action - locked
    LD      (IX+FM_RQPND),A     ; request pending

    POP     AF
    LD      (STRM_DRUMP),A      ; flags
    POP     AF
    LD      (STRM_DRUMV),A      ; block ID high
    POP     AF
    LD      (STRM_DRUMI),A      ; block ID low
    POP     AF
    LD      (STRM_ID),A         ; stream ID

    LD      A,$05
    LD      (REQ_ACT),A         ; request action - stream fast start
    JP      play_loop


; set BANKREG to DE (write b0 to serial register nine times)
set_bank
    LD      BC,BANKREG

    LD      A,E                 ; A = BA15-BA8 (BA14-BA8 ignored)
    RLCA
    LD      (BC),A              ; #1 = BA15

    LD      A,D                 ; A = BA23-BA16

    LD      (BC),A              ; #2 = BA16
    RRCA
    LD      (BC),A              ; #3 = BA17
    RRCA
    LD      (BC),A              ; #4 = BA18
    RRCA
    LD      (BC),A              ; #5 = BA19
    RRCA
    LD      (BC),A              ; #6 = BA20
    RRCA
    LD      (BC),A              ; #7 = BA21
    RRCA
    LD      (BC),A              ; #8 = BA22
    RRCA
    LD      (BC),A              ; #9 = BA23

    RET

#end