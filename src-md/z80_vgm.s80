#target ram
#code SRAM, $0000

; VGM player Z80 driver
; Joe Fenton (C)2023

; 32X Technical Notes
; 15. Z80 writes to $840000-$9FFFFF and $A15100-$A153FF will lock
;     the 68000. Writes to MD work RAM and PSG are allowed.
; 22. The Z80 bank shift register must not be set to $000000-
;     $3FFFFF or $840000-$9FFFFF. The 68000 may get inconsistent
;     data, and the 32X registers may become corrupted.


ACCURATE    EQU 1       ; set to 0 for 1.25, 1 for 1.1953125

LOCAL_MEM   EQU $0040   ; player variable base address
FM_IDX      EQU $00     ; music track index
FM_CSM      EQU $01     ; music CSM mode
FM_SMPL     EQU $02     ; music delay in samples (low)
FM_SMPH     EQU $03     ; music delay in samples (high)
FM_TICL     EQU $04     ; music timer ticks (low)
FM_TICH     EQU $05     ; music timer ticks (high)
FM_TTTL     EQU $06     ; music time to tick (low)
FM_TTTH     EQU $07     ; music time to tick (high)

FM_BUFCSM   EQU $08     ; music buffers consumed
FM_BUFGEN   EQU $09     ; music buffers generated

FM_RQPND    EQU $0A     ; 68000 request pending
FM_RQARG    EQU $0B     ;   request argument (if any)

FM_START    EQU $0C     ; start offset in sram (for starting/looping vgm)

CRITICAL    EQU $0F     ; Z80 critical section flag

VGMBUF      EQU $1000   ; last 4KB of sram holds VGM data (eight banks of 512 bytes)
VGMTOP      EQU $2000   ;

YM2612      EQU $4000   ; YM2612 base address
YMPORT0     EQU $00     ; YM2612 port 0 index
YMPORT1     EQU $01     ; YM2612 port 0 data
YMPORT2     EQU $02     ; YM2612 port 1 index
YMPORT3     EQU $03     ; YM2612 port 1 data

BANKREG     EQU $6000   ; Bank register
PSGPORT     EQU $7F11   ; PSG port


; variables at the top of 68000 work ram

MD_BANK     EQU $8000   ; base address of MD space bank in Z80 map

REQ_ATTR    EQU $FFEE
REQ_ACT     EQU $FFEF   ; request action by 68000

STRM_KON    EQU $FFF0
STRM_ID     EQU $FFF1
STRM_CHIP   EQU $FFF2
STRM_LMODE  EQU $FFF3
STRM_SSIZE  EQU $FFF4
STRM_SBASE  EQU $FFF5
STRM_FREQH  EQU $FFF6
STRM_FREQL  EQU $FFF7
STRM_OFFHH  EQU $FFF8
STRM_OFFHL  EQU $FFF9
STRM_OFFLH  EQU $FFFA
STRM_OFFLL  EQU $FFFB
STRM_LENHH  EQU $FFFC
STRM_LENHL  EQU $FFFD
STRM_LENLH  EQU $FFFE
STRM_LENLL  EQU $FFFF

STRM_DRUMI  EQU $FFF9
STRM_DRUMV  EQU $FFFA
STRM_DRUMP  EQU $FFFB

; ########################### Code starts here ##############################

;   ORG $0000

; basic init code
    DI                          ; Disable ints
    LD      SP,$1000            ; Setup stack (half-way to end of sram)
    IM      1                   ; Set int mode 1
    JP      start               ; Jump to start


; ########################## Interrupt handler ##############################

;   ORG     $0038
    defs    $0038 - $

interrupt
    RETI


; ############################## Main code ##################################

;   ORG     $0080
    defs    $0080 - $

start
    LD      DE,$FF80            ; bank set to top 32KB of 68000 Work RAM
    CALL    set_bank

start_loop
    LD      A,(LOCAL_MEM+FM_IDX)
    OR      A
    JR      Z,start_loop        ; not playing VGM music

    LD      BC,(LOCAL_MEM+FM_START)
    LD      HL,VGMBUF
    ADD     HL,BC
    LD      DE,VGMTOP
    LD      IX,LOCAL_MEM
    LD      IY,YM2612
    LD      (IX+FM_CSM),$15
    EXX
    LD      IX,LOCAL_MEM
    LD      IY,YM2612

    JP      load_voice
load_voice_return

play_loop_exx
    EXX
play_loop
    LD      A,(HL)              ; fetch next VGM byte
; increment vgm data ptr
    INC     L
    JP      NZ,dispatch         ; still on same page
    INC     H
    BIT     0,H
    CALL    Z,next_buffer       ; done two pages (each buffer is two pages)

dispatch
    LD      C,A

compare_type_note_off
    CP      $0                      ; if command == $0 (is it a note off command?)
    JP      Z,cmd_type_note_off

compare_type_spec
    CP      $C0                     ; if command < $C0 (is it NOT a special command?)
    JP      C,compare_type_note

jmp_spec
    JP      play_loop
    ; REMOVE JUMP ABOVE!
    LD      BC,spec_table
    PUSH    HL

    LD      H,0
    LD      L,A                     ; move command byte into HL
    ADD     HL,HL                   ; double HL
    ADD     HL,BC                   ; add spec_table offset to HL

    LD      A,(HL)                  ; retrieve first byte from spec_table
    INC     HL
    LD      H,(HL)                  ; retrieve second byte from spec_table
    LD      L,A
    JP      (HL)                    ; jump to appropriate command code

spec_table:
    .DW     cmd_wait_8bit
    .DW     cmd_wait_16bit
    .DW     0
    .DW     0
    .DW     0
    .DW     0
    .DW     0
    .DW     0
    .DW     cmd_stereo_off
    .DW     cmd_stereo_right
    .DW     cmd_stereo_left
    .DW     cmd_stereo_both
    .DW     cmd_octave_set
    .DW     cmd_voice_set
    .DW     cmd_vibrato_off
    .DW     cmd_vibrato_set

cmd_type_note_off
    ; TODO: Add code here!
    JP      play_loop

compare_type_note
    CP      $40                     ; if command < $40 (is it a wait command?)
    JP      C,cmd_type_wait
    ; Continue into cmd_type_note

cmd_type_note
    ; A = command (note) value

    PUSH    HL

    SUB     $40
    ADD     A,A
    LD      L,A
    LD      BC,freq_table           ; Get the note's frequency.
    ADD     HL,BC

    LD      A,$A4               ; address: channel frequency high byte
    LD      (IY+YMPORT0),A
    LD      (IY+YMPORT1),B      ; write dd to YM2612 port 0 register aa

    LD      A,$A0               ; address: channel frequency low byte
    LD      (IY+YMPORT0),A
    LD      (IY+YMPORT1),C      ; write dd to YM2612 port 0 register aa

    LD      A,$28               ; address: note on/off
    LD      B,$F0               ; play note on channel 1 with all operators
    LD      (IY+YMPORT0),A
    LD      (IY+YMPORT1),B      ; write dd to YM2612 port 0 register aa

    POP     HL
    JP      wait_test

    JP      play_loop


load_voice
    PUSH    HL

    LD      HL,voice_param_table
    
    LD      B,$B0               ; register
    LD      A,(HL)  ; $B0
    LD      (IY+YMPORT0),B
    LD      (IY+YMPORT1),A      ; write dd to YM2612 port 0 register aa
    INC     HL

    LD      B,$30               ; set initial destination register
load_voice_byte_loop
    LD      A,(HL)              ; read voice byte
    LD      (IY+YMPORT0),B
    LD      (IY+YMPORT1),A      ; write dd to YM2612 port 0 register aa
    INC     HL
    LD      A,B
    ADD     A,$4
    LD      B,A
    CP      $90
    JP      NZ,load_voice_byte_loop

    JP      load_voice_return


voice_param_table
    .DB     $38                     ; $B0 : FB/ALG
    .DB     $71, $72, $64, $73      ; $30 : DT/MUL
    .DB     $25, $19, $07, $11      ; $40 : TL
    .DB     $55, $5B, $1D, $1D      ; $50 : RS/AR
    .DB     $02, $8F, $0F, $04      ; $60 : AM/D1R
    .DB     $03, $00, $03, $01      ; $70 : D2R
    .DB     $66, $03, $13, $56      ; $80 : D1L/RR



    ;;;;; THIS IS ALL KINDS OF SCREWED UP! REWRITE!!
    PUSH    DE
    LD      D,(HL)                  ; 
    INC     L
    LD      BC,freq_table

    PUSH    HL
    LD      H,0
    LD      L,A
    ADD     HL,HL
    ADD     HL,BC

    LD      A,(HL)
    INC     HL
    LD      H,(HL)
    LD      L,A
    JP      (HL)    ;;;;;;; THIS SHOULD NOT BE A JUMP!

    LD      A,$A4
    LD      (IY+YMPORT0),A      ; Set the address at port 0
    LD      (IY+YMPORT1),D      ; Set the data at port 1
    POP     HL
    JP      play_loop

freq_table
    .DW     644     ; C
    .DW     681     ; C#
    .DW     722     ; D
    .DW     765     ; D#
    .DW     810     ; E
    .DW     858     ; F
    .DW     910     ; F#
    .DW     964     ; G
    .DW     1021    ; G#
    .DW     1081    ; A
    .DW     1146    ; A#
    .DW     1214    ; B

cmd_type_wait
    ; COMMAND: wait
    JP      play_loop

cmd_wait_8bit
    POP     HL
cmd_wait_16bit
    POP     HL
cmd_stereo_off
    POP     HL
cmd_stereo_right
    POP     HL
cmd_stereo_left
    POP     HL
cmd_stereo_both
    POP     HL
cmd_octave_set
    POP     HL
cmd_voice_set
    POP     HL
cmd_vibrato_off
    POP     HL
cmd_vibrato_set
    POP     HL










    LD      B,A
    AND     $F0
    CP      $70
    JP      Z,wait_nn           ; wait nn+1 sample periods
    LD      A,B
    CP      $50
    JP      Z,write_psg         ; write value dd to PSG
    CP      $52
    JP      Z,write_fm0         ; write value dd to YM2612 Port 0 register aa
    CP      $53
    JP      Z,write_fm1         ; write value dd to YM2612 Port 1 register aa
    CP      $62
    JP      Z,wait_735          ; wait 735 sample periods (1/60th sec)
    CP      $61
    JP      Z,wait_nnnn         ; wait nnnn sample periods
    CP      $95
    JP      Z,strm_fast         ; stream fast start
    CP      $66
    JP      Z,end_data          ; end of sound data
; unsupported command
    JP      end_data


waiting
    LD      A,(IY+YMPORT0)
    OR      A
    JP      M,waiting           ; busy
    BIT     0,A
    JR      Z,waiting           ; timer A not overflowed
; timer A overflow
    LD      HL,(LOCAL_MEM+FM_TICL)
    LD      BC,(LOCAL_MEM+FM_TTTL)
    OR      A                   ; clear carry
    SBC     HL,BC
    LD      (LOCAL_MEM+FM_TICL),HL  ; FM_TIC = FM_TIC - FM_TTT
    JR      NZ,set_timer        ; more ticks to wait
; delay done, process commands
    XOR     A
    LD      (IX+FM_SMPL),A
    LD      (IX+FM_SMPH),A
    LD      (IX+FM_TTTL),A
    LD      (IX+FM_TTTH),A
    JP      play_loop_exx

; timer ticks ~= sample delay * 1.2
calc_timer
    LD      HL,(LOCAL_MEM+FM_SMPL)
#if ACCURATE
    LD      BC,54928            ; 65535 / 1.1953125
    OR      A                   ; clear carry
    SBC     HL,BC
    JR      NC,overflow
    ADD     HL,BC
    LD      BC,HL
    SRL     B
    RR      C
    SRL     B
    RR      C
    SRL     B
    RR      C                   ; samples/8
    PUSH    BC
    SRL     B
    RR      C                   ; samples/16
    PUSH    BC
    SRL     B
    RR      C
    SRL     B
    RR      C
    SRL     B
    RR      C                   ; samples/128
    ADD     HL,BC
    POP     BC
    ADD     HL,BC
    POP     BC
    ADD     HL,BC               ; ticks = samples * 1.1953125
    JR      set_timer
#else
    LD      BC,HL
    SRL     B
    RR      C
    SRL     B
    RR      C                   ; samples >> 2
    ADD     HL,BC               ; ticks = samples * 1.25
    JR      NC,set_timer
#endif
overflow
    LD      HL,$FFFF
set_timer
    LD      (LOCAL_MEM+FM_TICL),HL  ; save total ticks
    LD      (LOCAL_MEM+FM_TTTL),HL  ; ticks for timer A = ticks
    LD      BC,$0400                ; max ticks for timer A (1024)
    OR      A                       ; clear carry
    SBC     HL,BC
    JR      C,set_tmr               ; ticks <= max ticks for timer A
    LD      (LOCAL_MEM+FM_TTTL),BC  ; use max ticks for timer A

set_tmr
    LD      HL,$0400
    LD      BC,(LOCAL_MEM+FM_TTTL)
    OR      A                   ; clear carry
    SBC     HL,BC               ; timer A count = $0400 - ticks for timer A
    LD      A,L
    AND     $03                 ; two lsbs = ttt & 3
    LD      E,A                 ; save two lsbs
    SRL     H
    RR      L
    SRL     H
    RR      L                   ; eight msbs = ttt >> 2
    LD      D,L                 ; save eight msbs

    LD      (IY+YMPORT0),$27
    LD      A,(IX+FM_CSM)
    AND     $FE
    LD      (IY+YMPORT1),A      ; reset timer A (keep current CSM)
    LD      (IY+YMPORT0),$24
    LD      (IY+YMPORT1),D      ; set timer A msbs
    LD      (IY+YMPORT0),$25
    LD      (IY+YMPORT1),E      ; set timer A lsbs
    LD      (IY+YMPORT0),$27
    OR      $01
    LD      (IY+YMPORT1),A      ; start timer A (keep current CSM)
    JP      waiting


next_buffer
; done two pages, signal 68000 to load another buffer
    EX      AF,AF'              ; save A
wait_pend
    LD      A,(IX+FM_RQPND)
    OR      A
    JR      NZ,wait_pend        ; request still pending

    LD      A,$FF
    LD      (REQ_ACT),A         ; request action - locked
    LD      (IX+FM_RQPND),A     ; request pending

    LD      A,(IX+FM_BUFCSM)
    INC     A
    LD      (IX+FM_BUFCSM),A    ; one more consumed
    LD      (IX+FM_RQARG),A     ; request arg = # buffers consumed & 0xFF

    LD      A,$01
    LD      (REQ_ACT),A         ; request action - read buffer

buf_wait
    LD      A,(IX+FM_BUFGEN)
    CP      (IX+FM_BUFCSM)
    JR      Z,buf_wait          ; make sure we have at least one buffer ready
    EX      AF,AF'              ; restore A

    ; check buffer wrap around
    OR      A                   ; clear carry
    SBC     HL,DE
    ADD     HL,DE               ; 16-bit compare
    JR      NZ,fetch_exit       ; haven't reached end of buffer
    LD      HL,VGMBUF           ; wrap around

fetch_exit
    RET


; write value dd to PSG
write_psg
    LD      A,(HL)              ; fetch dd
; increment vgm data ptr
    INC     L
    JP      NZ,set_psg          ; still on same page
    INC     H
    BIT     0,H
    CALL    Z,next_buffer       ; done two pages (each buffer is two pages)
set_psg
    LD      (PSGPORT),A         ; write dd to PSG
    JP      play_loop

; write value dd to YM2612 Port 0 register aa
write_fm0
    LD      A,(HL)              ; fetch aa
; increment vgm data ptr
    INC     L
    JP      NZ,get_fm0_dd       ; still on same page
    INC     H
    BIT     0,H
    CALL    Z,next_buffer       ; done two pages (each buffer is two pages)
get_fm0_dd
    LD      B,(HL)              ; fetch dd
; increment vgm data ptr
    INC     L
    JP      NZ,set_fm0          ; still on same page
    INC     H
    BIT     0,H
    CALL    Z,next_buffer       ; done two pages (each buffer is two pages)
set_fm0
    CP      $27                 ; check if writing CSM
    JR      NZ,wr_fm0           ; no
    LD      A,B
    AND     $40                 ; keep CSM bit
    OR      $15
    LD      (IX+FM_CSM),A
    LD      B,A
    LD      A,$27

wr_fm0
    LD      (IY+YMPORT0),A
    LD      (IY+YMPORT1),B      ; write dd to YM2612 port 0 register aa
    JP      play_loop

; write value dd to YM2612 Port 1 register aa
write_fm1
    LD      A,(HL)              ; fetch aa
; increment vgm data ptr
    INC     L
    JP      NZ,get_fm1_dd       ; still on same page
    INC     H
    BIT     0,H
    CALL    Z,next_buffer       ; done two pages (each buffer is two pages)
get_fm1_dd
    LD      B,(HL)              ; fetch dd
; increment vgm data ptr
    INC     L
    JP      NZ,set_fm1          ; still on same page
    INC     H
    BIT     0,H
    CALL    Z,next_buffer       ; done two pages (each buffer is two pages)
set_fm1
    LD      (IY+YMPORT2),A
    LD      (IY+YMPORT3),B      ; write dd to YM2612 port 1 register aa
    JP      play_loop

; wait nnnn sample periods
wait_nnnn
    LD      C,(HL)              ; fetch nn LSB
; increment vgm data ptr
    INC     L
    JP      NZ,get_nn_msb       ; still on same page
    INC     H
    BIT     0,H
    CALL    Z,next_buffer       ; done two pages (each buffer is two pages)
get_nn_msb
    LD      B,(HL)              ; fetch nn MSB
; increment vgm data ptr
    INC     L
    JP      NZ,set_nnnn         ; still on same page
    INC     H
    BIT     0,H
    CALL    Z,next_buffer       ; done two pages (each buffer is two pages)
set_nnnn
    LD      (LOCAL_MEM+FM_SMPL),BC
    EXX
    JP      calc_timer

; wait 735 sample periods (1/60th sec)
wait_735
    LD      BC,735
    LD      (LOCAL_MEM+FM_SMPL),BC
    EXX
    JP      calc_timer

; wait 22050 sample periods (1/2 sec)
wait_test
    LD      BC,22050
    LD      (LOCAL_MEM+FM_SMPL),BC
    EXX
    JP      calc_timer

; end of sound data
end_data
    LD      A,$FF
    LD      (REQ_ACT),A         ; request action - locked
    LD      (IX+FM_RQPND),A     ; request pending

    XOR     A
    LD      (IX+FM_IDX),A       ; music stopped
    LD      A,$02
    LD      (REQ_ACT),A         ; request action - music ended

end_wait
    LD      A,(IX+FM_RQPND)
    OR      A
    JR      NZ,end_wait

    LD      SP,$1000            ; reset stack (half-way to end of sram)
    LD      A,(LOCAL_MEM+FM_IDX)
    OR      A
    JP      Z,start_loop        ; not playing VGM music

    LD      BC,(LOCAL_MEM+FM_START)
    LD      HL,VGMBUF
    ADD     HL,BC
    CALL    next_buffer
    JP      play_loop           ; restart player

; wait nn+1 sample periods
wait_nn
    LD      A,B
    AND     $0F
    INC     A
    LD      C,A
    LD      B,0
    LD      (LOCAL_MEM+FM_SMPL),BC
    EXX
    JP      calc_timer


; Some notes for streams on the MD
;   There is only one YM2612, and thus only one DAC,
;   and thus only one stream. We can probably just
;   ignore it. We are also assuming an optimized VGM
;   with only one data block using stream command 93
;   to play samples.
;
;   We currently assume the length mode is 01, and
;   hence the number of samples to play at the set
;   frequency.

strm_get
    LD      A,(HL)              ; next VGM byte
; increment vgm data ptr
    INC     L
    JP      NZ,sgexit           ; still on same page
    INC     H
    BIT     0,H
    CALL    Z,next_buffer       ; done two pages (each buffer is two pages)
sgexit
    RET

; stream fast start
strm_fast
    LD      A,(IX+FM_RQPND)
    OR      A
    JR      NZ,strm_fast        ; request still pending

    CALL    strm_get            ; stream ID
    PUSH    AF
    CALL    strm_get            ; block ID low
    PUSH    AF
    CALL    strm_get            ; block ID high
    PUSH    AF
    CALL    strm_get            ; flags (0x01 == loop, 0x10 == reverse)
    PUSH    AF

    LD      A,$FF
    LD      (REQ_ACT),A         ; request action - locked
    LD      (IX+FM_RQPND),A     ; request pending

    POP     AF
    LD      (STRM_DRUMP),A      ; flags
    POP     AF
    LD      (STRM_DRUMV),A      ; block ID high
    POP     AF
    LD      (STRM_DRUMI),A      ; block ID low
    POP     AF
    LD      (STRM_ID),A         ; stream ID

    LD      A,$05
    LD      (REQ_ACT),A         ; request action - stream fast start
    JP      play_loop


; set BANKREG to DE (write b0 to serial register nine times)
set_bank
    LD      BC,BANKREG

    LD      A,E                 ; A = BA15-BA8 (BA14-BA8 ignored)
    RLCA
    LD      (BC),A              ; #1 = BA15

    LD      A,D                 ; A = BA23-BA16

    LD      (BC),A              ; #2 = BA16
    RRCA
    LD      (BC),A              ; #3 = BA17
    RRCA
    LD      (BC),A              ; #4 = BA18
    RRCA
    LD      (BC),A              ; #5 = BA19
    RRCA
    LD      (BC),A              ; #6 = BA20
    RRCA
    LD      (BC),A              ; #7 = BA21
    RRCA
    LD      (BC),A              ; #8 = BA22
    RRCA
    LD      (BC),A              ; #9 = BA23

    RET

#end